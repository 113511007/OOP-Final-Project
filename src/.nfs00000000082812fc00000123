#include "image_encryption.h"
#include <iostream>
#include <vector>
#include <bitset>
#include <stdexcept>

using namespace std;

bool ImageEncryption::encode(Image* image, const string& message) {
  if(!image || message.empty()) return false;
  if(image->get_channels() != 3) {
    cerr << "Only RGB images are supported for encoding\n";
  }
  vector<bool> bits = stringToBits(message);
  if(!checkCapacity(image, bits.size())) {
    cerr << "Image too small to hold the message\n";
  }
  int*** pixels = image->rgb_get_pixels();
  int width = image->get_width();
  int height = image->get_height();
  bitset<32> lenBits(bits.size());
  for(int i = 0; i < 32; ++i) {
    int x = (i / 3) % width;
    int y = (i / 3) / width;
    int ch = i % 3;
    pixels[y][x][ch] = (pixels[y][x][ch] & 0xFE) | lenBits[i];
  }
  size_t bitPos = 0;
  for(int y = 0; y < height && bitPos < bits.size(); ++y) {
    for(int x = 0; x < width && bitPos < bits.size(); ++x) {
      if(y == 0 && x < 10) continue;
        for(int ch = 0; ch < 3 && bitPos < bits.size(); ++ch) {
          pixels[y][x][ch] = (pixels[y][x][ch] & 0xFE) | bits[bitPos++];
        }
    }
  }
  return true;
}

string ImageEncryption::decode(const Image* image) {
  if(!image || image->get_channels() != 3) {
    cerr << "Invalid image for decoding\n";
  }
  int*** pixels = image->rgb_get_pixels();
  int width = image->get_width();
  int height = image->get_height();
  bitset<32> lenBits;
  for(int i = 0; i < 32; ++i) {
    int x = (i / 3) % width;
    int y = (i / 3) / width;
    int ch = i % 3;
    lenBits[i] = pixels[y][x][ch] & 1;
  }
  size_t msgLength = lenBits.to_ulong();
  if(msgLength == 0 || !checkCapacity(image, msgLength)) {
    return "";
  }
  vector<bool> bits;
  for(int y = 0; y < height && bits.size() < msgLength; ++y) {
    for(int x = 0; x < width && bits.size() < msgLength; ++x) {
      if(y == 0 && x < 10) continue;
        for(int ch = 0; ch < 3 && bits.size() < msgLength; ++ch) {
          bits.push_back(pixels[y][x][ch] & 1);
        }
    }
  }
  return bitsToString(bits);
}

bool ImageEncryption::checkCapacity(const Image* image, size_t messageLength) {
  int availableBits = (image->get_width() * image->get_height() * 3) - 32;
  return (messageLength <= availableBits);
}

vector<bool> ImageEncryption::stringToBits(const string& message) {
  vector<bool> bits;
  for(char c : message) {
    for(int i = 7; i >= 0; --i) {
      bits.push_back((c >> i) & 1);
    }
  }
  return bits;
}

string ImageEncryption::bitsToString(const vector<bool>& bits) {
  string message;
  for(size_t i = 0; i < bits.size(); i += 8) {
    char c = 0;
    for(int j = 0; j < 8 && (i + j) < bits.size(); ++j) {
      c |= bits[i + j] << (7 - j);
    }
    message += c;
  }
  return message;
}